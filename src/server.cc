#include <mutex>
#include <iomanip>
#include <iostream>
#include <fstream>
#include <sstream>

#include <yaml-cpp/yaml.h>
#include <grpc/grpc.h>
#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>
#include <grpcpp/server_context.h>
#include <grpcpp/security/credentials.h>
#include <grpcpp/security/server_credentials.h>
#include <cxxopts.hpp>
#include <botan/botan.h>
#include <botan/x509self.h>
#include <botan/rsa.h>
#include <botan/x509_ca.h>
#include <botan/system_rng.h>
#include <botan/pubkey.h>

#include "vactube_service.hpp"

/**
 * Reads a whole file to a std::string
 * Args:
 *  - filename: the path to the file to read
 */
std::string ReadFile(const std::string filename) {
  std::ifstream t(filename);
  std::stringstream buffer;
  buffer << t.rdbuf();
  return buffer.str();
}

/**
 * Runs a setup wizard that guides the user through 
 * the configuration of vactube and generates TLS 
 * keys to establish secure communications
 */
void SetupWizard() {
  YAML::Emitter out;
  std::string server_name, server_port;
  std::ofstream out_config("config.yaml");
  std::cout << R"(
  _    __           __        __       
  | |  / /___ ______/ /___  __/ /_  ___ 
  | | / / __ `/ ___/ __/ / / / __ \/ _ \
  | |/ / /_/ / /__/ /_/ /_/ / /_/ /  __/
  |___/\__,_/\___/\__/\__,_/_.___/\___/ 
                                        
  Thank you for using vactube, the self hosted alternative to cloud voice/video platforms.
  We'll get you setup in no time. Just a few questions here and there and you'll be ready to connect!
  If you ever need to change your settings, feel free to edit the yaml file generated by this wizard.
  First thing first: what do you want your server to be named?)" << std::endl;
  getline(std::cin, server_name,'\n');
  std::cout << "What port do you want the server to listen on?" << std::endl;
  getline(std::cin, server_port,'\n');
  
  out << YAML::BeginDoc << YAML::BeginMap;
  out << YAML::Key << "server_name" << YAML::DoubleQuoted << server_name;
  out << YAML::Key << "server_address" << YAML::DoubleQuoted << "0.0.0.0:" + server_port;
  out << YAML::Key << "ssl" << YAML::BeginMap;
  out << YAML::Key << "key" << YAML::DoubleQuoted << "key.pem";
  out << YAML::Key << "cert" << YAML::DoubleQuoted << "cert.pem" << YAML::EndMap;
  out << YAML::EndMap << YAML::EndDoc;

  out_config << std::string(out.c_str());
  GenCerts();
  out_config.flush();
  std::cout << "The configuration has been written to config.yaml. With that, vactube is ready" << std::endl;
}

/***
 * Generates a private key and a corresponding self signed certificate for the server
 * Args: 
 *  - pkey_filename: the name of the (new) file to save the private key data to   
 *  - cert_filename: the name of the (new) file to save the certificate data to
 */
void GenCerts(std::string pkey_filename = "key.pem", std::string cert_filename = "cert.pem") {
  std::ofstream pkey_out(pkey_filename);
  std::ofstream cert_out(cert_filename);

  std::unique_ptr<Botan::RandomNumberGenerator> rng;
  #if defined(BOTAN_HAS_SYSTEM_RNG)
  rng.reset(new Botan::System_RNG);
  #else
  rng.reset(new Botan::AutoSeeded_RNG);
  #endif

  Botan::RSA_PrivateKey pkey = Botan::RSA_PrivateKey(*rng, 2048);
  Botan::X509_Cert_Options self_options = Botan::X509_Cert_Options("localhost");
  Botan::X509_Certificate cert = Botan::X509::create_self_signed_cert(self_options, pkey, "SHA-256", *rng);

  pkey_out <<  Botan::PKCS8::PEM_encode(pkey);
  cert_out <<  cert.PEM_encode();
}

int main(int argc, char **argv)
{
  VactubeImpl service;
  grpc::ServerBuilder builder;

  // Options Parsing
  cxxopts::Options options("vactube-server", "The server part of vactube. A drop in replacement for cloud chatting platforms");
  options.add_options()("c,config", "Path to the yaml config file", cxxopts::value<std::string>())
                       ("g,generate", "Generate the configuration files and ssl certificates", cxxopts::value<bool>()->default_value("false"))
                       ("h,help", "Print this help message");
  auto args = options.parse(argc, argv);
  
  // Display the help if no config / generate or help requested
  if((!args.count("config") && !args.count("generate")) || args.count("help")) {
    std::cout << options.help();
    std::exit(0);
  }


  if(args.count("generate")) {
    SetupWizard();
    std::exit(0);
  }
  
  YAML::Node config = YAML::LoadFile(args["config"].as<std::string>());
  std::string server_address = config["server_address"].as<std::string>();

  if(config["ssl"].IsDefined()) {
    std::string key = ReadFile(config["ssl"]["key"].as<std::string>());
    std::string crt = ReadFile(config["ssl"]["cert"].as<std::string>());
    grpc::SslServerCredentialsOptions::PemKeyCertPair keycert =
    {
      key,
      crt
    };
    auto ssl_opts = grpc::SslServerCredentialsOptions();
    ssl_opts.pem_root_certs = "";
    ssl_opts.pem_key_cert_pairs.push_back(keycert);
    auto server_creds = grpc::SslServerCredentials(ssl_opts);
    builder.AddListeningPort(server_address, server_creds);
  }
  else {
    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
  }
  builder.RegisterService(&service);
  std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
  std::cout << "Server listening on " << server_address << std::endl;
  server->Wait();
  return 0;
}
